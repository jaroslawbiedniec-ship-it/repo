import sqlite3
import json
from collections import Counter
import os
from dataclasses import dataclass
from typing import List, Optional, Tuple, Dict, Any, Union


@dataclass
class Book:
    """Class representing a book."""
    title: str
    author: str
    year: int
    category: str
    id: int = None
    favorite: bool = False
    read_count: int = 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert book to dictionary for JSON serialization."""
        return {
            'id': self.id,
            'title': self.title,
            'author': self.author,
            'year': self.year,
            'category': self.category,
            'favorite': self.favorite,
            'read_count': self.read_count
        }

    @classmethod
    def from_row(cls, row: Tuple) -> 'Book':
        """Create a Book object from a database row."""
        return cls(
            id=row[0],
            title=row[1],
            author=row[2],
            year=row[3],
            category=row[4],
            favorite=bool(row[5]),
            read_count=row[6]
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Book':
        """Create a Book object from a dictionary."""
        return cls(
            id=data.get('id'),
            title=data['title'],
            author=data['author'],
            year=data.get('year'),
            category=data.get('category'),
            favorite=data.get('favorite', False),
            read_count=data.get('read_count', 0)
        )


class BookManager:
    """Class for managing a collection of books in a database."""
    
    def __init__(self, db_name='books.db'):
        self.db_name = db_name
        self.conn = sqlite3.connect(db_name)
        self.create_table()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def create_table(self):
        """Create the books table if it doesn't exist."""
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                author TEXT NOT NULL,
                year INTEGER,
                category TEXT,
                favorite BOOLEAN DEFAULT FALSE,
                read_count INTEGER DEFAULT 0
            )
        ''')
        self.conn.commit()

    def add_book(self, title: str, author: str, year: int, category: str) -> int:
        """Add a new book to the database."""
        # Validate inputs
        if not title or not author:
            print("Błąd: Tytuł i autor są wymagane.")
            return None
            
        if not isinstance(year, int) or year < 0 or year > 9999:
            print("Błąd: Rok musi być liczbą całkowitą między 0 a 9999.")
            return None
            
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                INSERT INTO books (title, author, year, category)
                VALUES (?, ?, ?, ?)
            ''', (title, author, year, category or "Brak kategorii"))
            self.conn.commit()
            print(f"Książka '{title}' dodana pomyślnie.")
            return cursor.lastrowid
        except sqlite3.Error as e:
            print(f"Błąd podczas dodawania książki: {e}")
            return None

    def search_books(self, query: str) -> List[Book]:
        """Search for books by title, author, or category."""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT * FROM books
                WHERE title LIKE ? OR author LIKE ? OR category LIKE ?
            ''', (f'%{query}%', f'%{query}%', f'%{query}%'))
            return [Book.from_row(row) for row in cursor.fetchall()]
        except sqlite3.Error as e:
            print(f"Błąd podczas wyszukiwania książek: {e}")
            return []

    def filter_books(self, category: Optional[str] = None, 
                    year: Optional[int] = None, 
                    favorite: bool = False) -> List[Book]:
        """Filter books by category, year, and/or favorite status."""
        try:
            cursor = self.conn.cursor()
            query = 'SELECT * FROM books WHERE 1=1'
            params = []
            if category:
                query += ' AND category = ?'
                params.append(category)
            if year:
                query += ' AND year = ?'
                params.append(year)
            if favorite:
                query += ' AND favorite = 1'
            cursor.execute(query, params)
            return [Book.from_row(row) for row in cursor.fetchall()]
        except sqlite3.Error as e:
            print(f"Błąd podczas filtrowania książek: {e}")
            return []

    def mark_favorite(self, book_id: int, favorite: bool = True) -> bool:
        """Mark a book as favorite or not favorite."""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                UPDATE books SET favorite = ? WHERE id = ?
            ''', (1 if favorite else 0, book_id))
            self.conn.commit()
            if cursor.rowcount > 0:
                print(f"Książka o ID {book_id} oznaczona jako ulubiona: {favorite}.")
                return True
            else:
                print(f"Nie znaleziono książki o ID {book_id}.")
                return False
        except sqlite3.Error as e:
            print(f"Błąd podczas oznaczania książki jako ulubionej: {e}")
            return False

    def increment_read_count(self, book_id: int) -> bool:
        """Increment the read count for a book."""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                UPDATE books SET read_count = read_count + 1 WHERE id = ?
            ''', (book_id,))
            self.conn.commit()
            if cursor.rowcount > 0:
                print(f"Licznik odczytów dla książki o ID {book_id} zwiększony.")
                return True
            else:
                print(f"Nie znaleziono książki o ID {book_id}.")
                return False
        except sqlite3.Error as e:
            print(f"Błąd podczas zwiększania licznika odczytów: {e}")
            return False

    def get_favorites(self) -> List[Book]:
        """Get all favorite books."""
        return self.filter_books(favorite=True)

    def get_most_read_categories(self) -> List[Tuple[str, int]]:
        """Get categories sorted by total read count."""
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT category, SUM(read_count) as total_reads
                FROM books
                GROUP BY category
                ORDER BY total_reads DESC
            ''')
            return cursor.fetchall()
        except sqlite3.Error as e:
            print(f"Błąd podczas pobierania najczęściej czytanych kategorii: {e}")
            return []

    def get_most_common_categories(self) -> List[Tuple[str, int]]:
        """Get categories sorted by number of books."""
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT category FROM books')
            categories = [row[0] for row in cursor.fetchall() if row[0]]
            counter = Counter(categories)
            return counter.most_common()
        except sqlite3.Error as e:
            print(f"Błąd podczas pobierania najczęściej występujących kategorii: {e}")
            return []

    def edit_book(self, book_id: int, title: Optional[str] = None, 
                 author: Optional[str] = None, year: Optional[int] = None, 
                 category: Optional[str] = None) -> bool:
        """Edit a book's information."""
        try:
            cursor = self.conn.cursor()
            updates = []
            params = []
            if title:
                updates.append('title = ?')
                params.append(title)
            if author:
                updates.append('author = ?')
                params.append(author)
            if year:
                updates.append('year = ?')
                params.append(year)
            if category:
                updates.append('category = ?')
                params.append(category)
            
            if not updates:
                print("Brak danych do aktualizacji.")
                return False
                
            query = f'UPDATE books SET {", ".join(updates)} WHERE id = ?'
            params.append(book_id)
            cursor.execute(query, params)
            self.conn.commit()
            
            if cursor.rowcount > 0:
                print(f"Książka o ID {book_id} edytowana.")
                return True
            else:
                print(f"Nie znaleziono książki o ID {book_id}.")
                return False
        except sqlite3.Error as e:
            print(f"Błąd podczas edycji książki: {e}")
            return False

    def delete_book(self, book_id: int) -> bool:
        """Delete a book from the database."""
        try:
            cursor = self.conn.cursor()
            cursor.execute('DELETE FROM books WHERE id = ?', (book_id,))
            self.conn.commit()
            if cursor.rowcount > 0:
                print(f"Książka o ID {book_id} usunięta.")
                return True
            else:
                print(f"Nie znaleziono książki o ID {book_id}.")
                return False
        except sqlite3.Error as e:
            print(f"Błąd podczas usuwania książki: {e}")
            return False

    def export_to_json(self, filename: str = 'books.json') -> bool:
        """Export all books to a JSON file."""
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT * FROM books')
            rows = cursor.fetchall()
            books = [Book.from_row(row).to_dict() for row in rows]
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(books, f, ensure_ascii=False, indent=4)
            print(f"Dane wyeksportowane do {filename}.")
            return True
        except (sqlite3.Error, IOError) as e:
            print(f"Błąd podczas eksportu do JSON: {e}")
            return False

    def import_from_json(self, filename: str = 'books.json') -> bool:
        """Import books from a JSON file."""
        if not os.path.exists(filename):
            print(f"Plik {filename} nie istnieje.")
            return False
            
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                books_data = json.load(f)
                
            for book_data in books_data:
                book = Book.from_dict(book_data)
                book_id = self.add_book(book.title, book.author, book.year, book.category)
                
                if book_id and book.favorite:
                    self.mark_favorite(book_id, True)
                    
                if book_id and book.read_count > 0:
                    cursor = self.conn.cursor()
                    cursor.execute('UPDATE books SET read_count = ? WHERE id = ?', 
                                  (book.read_count, book_id))
                    self.conn.commit()
                    
            print(f"Dane zaimportowane z {filename}.")
            return True
        except (json.JSONDecodeError, IOError, sqlite3.Error) as e:
            print(f"Błąd podczas importu z JSON: {e}")
            return False

    def close(self):
        """Close the database connection."""
        if hasattr(self, 'conn') and self.conn:
            self.conn.close()
            print("Połączenie z bazą danych zamknięte.")


class BookUI:
    """User interface for the book management system."""
    
    def __init__(self, manager: BookManager):
        self.manager = manager
        
    def print_books(self, books: List[Book]):
        """Print a list of books with improved formatting."""
        if not books:
            print("Brak książek.")
            return
        
        print("\n" + "="*80)
        print(f"{'ID':^5}|{'Tytuł':^25}|{'Autor':^20}|{'Rok':^6}|{'Kategoria':^15}|{'Ulubiona':^8}|{'Odczyty':^8}")
        print("-"*80)
        
        for book in books:
            title = book.title[:22] + "..." if len(book.title) > 22 else book.title
            author = book.author[:17] + "..." if len(book.author) > 17 else book.author
            category = book.category[:12] + "..." if len(book.category) > 12 else book.category
            favorite = "Tak" if book.favorite else "Nie"
            
            print(f"{book.id:^5}|{title:^25}|{author:^20}|{book.year:^6}|{category:^15}|{favorite:^8}|{book.read_count:^8}")
        
        print("="*80)
    
    def get_int_input(self, prompt: str) -> Optional[int]:
        """Get integer input from the user with validation."""
        while True:
            try:
                value = input(prompt)
                if not value:
                    return None
                result = int(value)
                if result < 0:
                    print("Proszę wprowadzić liczbę dodatnią.")
                    continue
                return result
            except ValueError:
                print("Proszę wprowadzić liczbę całkowitą.")
    
    def run(self):
        """Run the main application loop."""
        while True:
            print("\nMenu:")
            print("1. Dodaj książkę")
            print("2. Szukaj książek")
            print("3. Filtruj książki")
            print("4. Oznacz jako ulubioną")
            print("5. Zwiększ licznik odczytów")
            print("6. Pokaż ulubione")
            print("7. Najczęściej czytane kategorie (na podstawie odczytów)")
            print("8. Najczęściej występujące kategorie")
            print("9. Edytuj książkę")
            print("10. Usuń książkę")
            print("11. Eksportuj do JSON")
            print("12. Importuj z JSON")
            print("13. Wyjście")
            
            choice = input("Wybierz opcję: ")
            
            if choice == '1':
                self.add_book_ui()
            elif choice == '2':
                self.search_books_ui()
            elif choice == '3':
                self.filter_books_ui()
            elif choice == '4':
                self.mark_favorite_ui()
            elif choice == '5':
                self.increment_read_count_ui()
            elif choice == '6':
                self.show_favorites_ui()
            elif choice == '7':
                self.show_most_read_categories_ui()
            elif choice == '8':
                self.show_most_common_categories_ui()
            elif choice == '9':
                self.edit_book_ui()
            elif choice == '10':
                self.delete_book_ui()
            elif choice == '11':
                self.export_to_json_ui()
            elif choice == '12':
                self.import_from_json_ui()
            elif choice == '13':
                break
            else:
                print("Nieprawidłowa opcja.")
    
    def add_book_ui(self):
        """UI for adding a book."""
        title = input("Tytuł: ")
        author = input("Autor: ")
        year = self.get_int_input("Rok: ")
        category = input("Kategoria: ")
        
        if title and author and year:
            self.manager.add_book(title, author, year, category)
        else:
            print("Tytuł, autor i rok są wymagane.")
    
    def search_books_ui(self):
        """UI for searching books."""
        query = input("Wyszukaj (tytuł/autor/kategoria): ")
        books = self.manager.search_books(query)
        self.print_books(books)
    
    def filter_books_ui(self):
        """UI for filtering books."""
        category = input("Kategoria (opcjonalnie): ") or None
        year = self.get_int_input("Rok (opcjonalnie): ")
        favorite = input("Tylko ulubione? (t/n): ").lower() == 't'
        
        books = self.manager.filter_books(category, year, favorite)
        self.print_books(books)
    
    def mark_favorite_ui(self):
        """UI for marking a book as favorite."""
        book_id = self.get_int_input("ID książki: ")
        if book_id is None:
            print("Nieprawidłowe ID książki.")
            return
            
        favorite = input("Ulubiona? (t/n): ").lower() == 't'
        self.manager.mark_favorite(book_id, favorite)
    
    def increment_read_count_ui(self):
        """UI for incrementing a book's read count."""
        book_id = self.get_int_input("ID książki: ")
        if book_id is None:
            print("Nieprawidłowe ID książki.")
            return
            
        self.manager.increment_read_count(book_id)
    
    def show_favorites_ui(self):
        """UI for showing favorite books."""
        favorites = self.manager.get_favorites()
        self.print_books(favorites)
    
    def show_most_read_categories_ui(self):
        """UI for showing most read categories."""
        categories = self.manager.get_most_read_categories()
        print("Najczęściej czytane kategorie:")
        for cat in categories:
            print(f"{cat[0]}: {cat[1]} odczytów")
    
    def show_most_common_categories_ui(self):
        """UI for showing most common categories."""
        categories = self.manager.get_most_common_categories()
        print("Najczęściej występujące kategorie:")
        for cat, count in categories:
            print(f"{cat}: {count} książek")
    
    def edit_book_ui(self):
        """UI for editing a book."""
        book_id = self.get_int_input("ID książki: ")
        if book_id is None:
            print("Nieprawidłowe ID książki.")
            return
            
        title = input("Nowy tytuł (enter by pominąć): ") or None
        author = input("Nowy autor (enter by pominąć): ") or None
        year = self.get_int_input("Nowy rok (enter by pominąć): ")
        category = input("Nowa kategoria (enter by pominąć): ") or None
        
        self.manager.edit_book(book_id, title, author, year, category)
    
    def delete_book_ui(self):
        """UI for deleting a book."""
        book_id = self.get_int_input("ID książki: ")
        if book_id is None:
            print("Nieprawidłowe ID książki.")
            return
            
        confirm = input(f"Czy na pewno chcesz usunąć książkę o ID {book_id}? (t/n): ").lower() == 't'
        if confirm:
            self.manager.delete_book(book_id)
        else:
            print("Usuwanie anulowane.")
    
    def export_to_json_ui(self):
        """UI for exporting books to JSON."""
        filename = input("Nazwa pliku JSON (domyślnie books.json): ") or 'books.json'
        self.manager.export_to_json(filename)
    
    def import_from_json_ui(self):
        """UI for importing books from JSON."""
        filename = input("Nazwa pliku JSON (domyślnie books.json): ") or 'books.json'
        self.manager.import_from_json(filename)


def main():
    """Main function to run the application."""
    with BookManager() as manager:
        ui = BookUI(manager)
        ui.run()


if __name__ == "__main__":
    main()